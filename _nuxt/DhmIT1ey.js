import{u as O,g as _,a as A,b as C,c as T,d as L,e as F}from"./5Ldd-9pg.js";import{D as P,$ as y,m as E,p as W,E as U}from"./CIZ0559i.js";import{c as x}from"./D-2laYAh.js";import"./BN_7HF1G.js";import"./CV4Hssdo.js";import"./733plaHR.js";function N(r){return!r||typeof r.then!="function"?Promise.resolve(r):r}function d(r,...n){try{return N(r(...n))}catch(a){return Promise.reject(a)}}function H(r){const n=typeof r;return r===null||n!=="object"&&n!=="function"}function b(r){const n=Object.getPrototypeOf(r);return!n||n.isPrototypeOf(Object)}function D(r){if(H(r))return String(r);if(b(r)||Array.isArray(r))return JSON.stringify(r);if(typeof r.toJSON=="function")return D(r.toJSON());throw new Error("[unstorage] Cannot stringify value!")}const R="base64:";function z(r){return typeof r=="string"?r:R+V(r)}function J(r){return typeof r!="string"||!r.startsWith(R)?r:q(r.slice(R.length))}function q(r){return globalThis.Buffer?Buffer.from(r,"base64"):Uint8Array.from(globalThis.atob(r),n=>n.codePointAt(0))}function V(r){return globalThis.Buffer?Buffer.from(r).toString("base64"):globalThis.btoa(String.fromCodePoint(...r))}function w(r){return r&&r.split("?")[0]?.replace(/[/\\]/g,":").replace(/:+/g,":").replace(/^:|:$/g,"")||""}function X(...r){return w(r.join(":"))}function B(r){return r=w(r),r?r+":":""}function G(r,n){if(n===void 0)return!0;let a=0,g=r.indexOf(":");for(;g>-1;)a++,g=r.indexOf(":",g+1);return a<=n}function Q(r,n){return n?r.startsWith(n)&&r[r.length-1]!=="$":r[r.length-1]!=="$"}const Y="memory",Z=()=>{const r=new Map;return{name:Y,getInstance:()=>r,hasItem(n){return r.has(n)},getItem(n){return r.get(n)??null},getItemRaw(n){return r.get(n)??null},setItem(n,a){r.set(n,a)},setItemRaw(n,a){r.set(n,a)},removeItem(n){r.delete(n)},getKeys(){return[...r.keys()]},clear(){r.clear()},dispose(){r.clear()}}};function k(r={}){const n={mounts:{"":r.driver||Z()},mountpoints:[""],watching:!1,watchListeners:[],unwatch:{}},a=t=>{for(const e of n.mountpoints)if(t.startsWith(e))return{base:e,relativeKey:t.slice(e.length),driver:n.mounts[e]};return{base:"",relativeKey:t,driver:n.mounts[""]}},g=(t,e)=>n.mountpoints.filter(o=>o.startsWith(t)||e&&t.startsWith(o)).map(o=>({relativeBase:t.length>o.length?t.slice(o.length):void 0,mountpoint:o,driver:n.mounts[o]})),m=(t,e)=>{if(n.watching){e=w(e);for(const o of n.watchListeners)o(t,e)}},s=async()=>{if(!n.watching){n.watching=!0;for(const t in n.mounts)n.unwatch[t]=await $(n.mounts[t],m,t)}},c=async()=>{if(n.watching){for(const t in n.unwatch)await n.unwatch[t]();n.unwatch={},n.watching=!1}},f=(t,e,o)=>{const i=new Map,u=l=>{let v=i.get(l.base);return v||(v={driver:l.driver,base:l.base,items:[]},i.set(l.base,v)),v};for(const l of t){const v=typeof l=="string",p=w(v?l:l.key),M=v?void 0:l.value,I=v||!l.options?e:{...e,...l.options},K=a(p);u(K).items.push({key:p,value:M,relativeKey:K.relativeKey,options:I})}return Promise.all([...i.values()].map(l=>o(l))).then(l=>l.flat())},h={hasItem(t,e={}){t=w(t);const{relativeKey:o,driver:i}=a(t);return d(i.hasItem,o,e)},getItem(t,e={}){t=w(t);const{relativeKey:o,driver:i}=a(t);return d(i.getItem,o,e).then(u=>P(u))},getItems(t,e={}){return f(t,e,o=>o.driver.getItems?d(o.driver.getItems,o.items.map(i=>({key:i.relativeKey,options:i.options})),e).then(i=>i.map(u=>({key:X(o.base,u.key),value:P(u.value)}))):Promise.all(o.items.map(i=>d(o.driver.getItem,i.relativeKey,i.options).then(u=>({key:i.key,value:P(u)})))))},getItemRaw(t,e={}){t=w(t);const{relativeKey:o,driver:i}=a(t);return i.getItemRaw?d(i.getItemRaw,o,e):d(i.getItem,o,e).then(u=>J(u))},async setItem(t,e,o={}){if(e===void 0)return h.removeItem(t);t=w(t);const{relativeKey:i,driver:u}=a(t);u.setItem&&(await d(u.setItem,i,D(e),o),u.watch||m("update",t))},async setItems(t,e){await f(t,e,async o=>{if(o.driver.setItems)return d(o.driver.setItems,o.items.map(i=>({key:i.relativeKey,value:D(i.value),options:i.options})),e);o.driver.setItem&&await Promise.all(o.items.map(i=>d(o.driver.setItem,i.relativeKey,D(i.value),i.options)))})},async setItemRaw(t,e,o={}){if(e===void 0)return h.removeItem(t,o);t=w(t);const{relativeKey:i,driver:u}=a(t);if(u.setItemRaw)await d(u.setItemRaw,i,e,o);else if(u.setItem)await d(u.setItem,i,z(e),o);else return;u.watch||m("update",t)},async removeItem(t,e={}){typeof e=="boolean"&&(e={removeMeta:e}),t=w(t);const{relativeKey:o,driver:i}=a(t);i.removeItem&&(await d(i.removeItem,o,e),(e.removeMeta||e.removeMata)&&await d(i.removeItem,o+"$",e),i.watch||m("remove",t))},async getMeta(t,e={}){typeof e=="boolean"&&(e={nativeOnly:e}),t=w(t);const{relativeKey:o,driver:i}=a(t),u=Object.create(null);if(i.getMeta&&Object.assign(u,await d(i.getMeta,o,e)),!e.nativeOnly){const l=await d(i.getItem,o+"$",e).then(v=>P(v));l&&typeof l=="object"&&(typeof l.atime=="string"&&(l.atime=new Date(l.atime)),typeof l.mtime=="string"&&(l.mtime=new Date(l.mtime)),Object.assign(u,l))}return u},setMeta(t,e,o={}){return this.setItem(t+"$",e,o)},removeMeta(t,e={}){return this.removeItem(t+"$",e)},async getKeys(t,e={}){t=B(t);const o=g(t,!0);let i=[];const u=[];let l=!0;for(const p of o){p.driver.flags?.maxDepth||(l=!1);const M=await d(p.driver.getKeys,p.relativeBase,e);for(const I of M){const K=p.mountpoint+w(I);i.some(j=>K.startsWith(j))||u.push(K)}i=[p.mountpoint,...i.filter(I=>!I.startsWith(p.mountpoint))]}const v=e.maxDepth!==void 0&&!l;return u.filter(p=>(!v||G(p,e.maxDepth))&&Q(p,t))},async clear(t,e={}){t=B(t),await Promise.all(g(t,!1).map(async o=>{if(o.driver.clear)return d(o.driver.clear,o.relativeBase,e);if(o.driver.removeItem){const i=await o.driver.getKeys(o.relativeBase||"",e);return Promise.all(i.map(u=>o.driver.removeItem(u,e)))}}))},async dispose(){await Promise.all(Object.values(n.mounts).map(t=>S(t)))},async watch(t){return await s(),n.watchListeners.push(t),async()=>{n.watchListeners=n.watchListeners.filter(e=>e!==t),n.watchListeners.length===0&&await c()}},async unwatch(){n.watchListeners=[],await c()},mount(t,e){if(t=B(t),t&&n.mounts[t])throw new Error(`already mounted at ${t}`);return t&&(n.mountpoints.push(t),n.mountpoints.sort((o,i)=>i.length-o.length)),n.mounts[t]=e,n.watching&&Promise.resolve($(e,m,t)).then(o=>{n.unwatch[t]=o}).catch(console.error),h},async unmount(t,e=!0){t=B(t),!(!t||!n.mounts[t])&&(n.watching&&t in n.unwatch&&(n.unwatch[t]?.(),delete n.unwatch[t]),e&&await S(n.mounts[t]),n.mountpoints=n.mountpoints.filter(o=>o!==t),delete n.mounts[t])},getMount(t=""){t=w(t)+":";const e=a(t);return{driver:e.driver,base:e.base}},getMounts(t="",e={}){return t=w(t),g(t,e.parents).map(i=>({driver:i.driver,base:i.mountpoint}))},keys:(t,e={})=>h.getKeys(t,e),get:(t,e={})=>h.getItem(t,e),set:(t,e,o={})=>h.setItem(t,e,o),has:(t,e={})=>h.hasItem(t,e),del:(t,e={})=>h.removeItem(t,e),remove:(t,e={})=>h.removeItem(t,e)};return h}function $(r,n,a){return r.watch?r.watch((g,m)=>n(g,a+m)):()=>{}}async function S(r){typeof r.dispose=="function"&&await d(r.dispose)}const tt="http",et=r=>{const n=(s="")=>E(r.base,s.replace(/:/g,"/")),a=(s="")=>E(r.base,(s||"/").replace(/:/g,"/"),":"),g=(s,c=null)=>{if(s?.response?.status===404)return c;throw s},m=(s,c)=>{const f={...c,...r.headers,...s?.headers};return s?.ttl&&!f["x-ttl"]&&(f["x-ttl"]=s.ttl+""),f};return{name:tt,options:r,hasItem(s,c){return y(n(s),{method:"HEAD",headers:m(c)}).then(()=>!0).catch(f=>g(f,!1))},async getItem(s,c){return await y(n(s),{headers:m(c)}).catch(g)},async getItemRaw(s,c){return(await y.raw(n(s),{responseType:"arrayBuffer",headers:m(c,{accept:"application/octet-stream"})}).catch(g))._data},async getMeta(s,c){const f=await y.raw(n(s),{method:"HEAD",headers:m(c)});let h,t;const e=f.headers.get("last-modified");e&&(h=new Date(e));const o=f.headers.get("x-ttl");return o&&(t=Number.parseInt(o,10)),{status:f.status,mtime:h,ttl:t}},async setItem(s,c,f){await y(n(s),{method:"PUT",body:c,headers:m(f)})},async setItemRaw(s,c,f){await y(n(s),{method:"PUT",body:c,headers:m(f,{"content-type":"application/octet-stream"})})},async removeItem(s,c){await y(n(s),{method:"DELETE",headers:m(c)})},async getKeys(s,c){const f=await y(a(s),{headers:m(c)});return Array.isArray(f)?f:[]},async clear(s,c){await y(a(s),{method:"DELETE",headers:m(c)})}}};function ct(r,n){const a=O(r,n);if(!W().public.studio.dev)return a;a.meta.dev=!0;const g=k({driver:et({base:"/__nuxt_studio/dev/content"})});return a.app.requestRerender=()=>{},a.document.db.upsert=U(async(m,s)=>{const c=_(m,x);if(!c)throw new Error(`Collection not found for fsPath: ${m}`);const f=A(m,c),h=C(f,c,s),t=await a.document.generate.contentFromDocument(h);await $fetch("/__nuxt_studio/dev/content/"+m,{method:"PUT",body:t,headers:{"content-type":"text/plain"},timeout:100}).catch(()=>{})},100),a.document.db.delete=async m=>{await g.removeItem(m)},a.on.documentUpdate=m=>{(void 0).on("nuxt-content:update",s=>{const c=T(s.key,x),f=L(s.key,c.source),h=F(s.key,f),t=s.queries.length===0;m(h,t?"remove":"update")})},a.on.mediaUpdate=m=>{(void 0).on("nuxt-studio:media:update",s=>{m(s.id,s.type)})},a}export{ct as useStudioHost};
