---
title: "Backend Architecture"
description: "Deep dive into DevStride's backend architecture, patterns, and conventions."
---

# Backend Architecture

The DevStride backend is built on Domain-Driven Design (DDD) principles with CQRS (Command Query Responsibility Segregation) and event-driven architecture.

## Technology Stack

| Technology | Purpose |
|------------|---------|
| **Node.js 22** | Runtime |
| **TypeScript** | Type-safe development (strict mode) |
| **Hono** | Lightweight web framework for API handlers |
| **Pulumi** | Infrastructure-as-code |
| **DynamoDB** | NoSQL database (via dynamodb-onetable) |
| **PostgreSQL** | Relational database (via Drizzle ORM) |
| **BottleJS** | Dependency injection |
| **@badrap/result** | Result pattern for error handling |

## Project Structure

```
backend/src/
├── libs/
│   ├── domain/           # Shared domain primitives
│   │   ├── ports/        # Interface definitions
│   │   └── config.ts     # Configuration schema
│   ├── infrastructure/   # Shared infrastructure
│   │   ├── pusher/       # Real-time messaging
│   │   └── ...
│   └── exceptions/       # Exception classes
│
├── modules/              # Domain modules
│   ├── item/
│   ├── board/
│   ├── user/
│   ├── organization/
│   └── ...
│
└── local.ts              # Application entry point (local development server)
```

## Module Structure

Each domain module follows a consistent structure:

```
modules/item/
├── domain/
│   ├── entities/              # Domain entities
│   │   └── work-item.entity.ts
│   ├── value-objects/         # Value objects
│   │   └── item-number.value-object.ts
│   ├── events/                # Domain events
│   │   └── work-item-created.domain-event.ts
│   └── utils/                 # Domain utilities
│
├── commands/                  # Write operations (top-level, not under application/)
│   └── create-work-item/
│       ├── create-work-item.command.ts
│       ├── create-work-item.service.ts
│       ├── create-work-item.init.ts
│       └── create-work-item.hono.handler.ts
│
├── queries/                   # Read operations (top-level, not under application/)
│   └── get-work-item-by-id/
│       ├── get-work-item-by-id.query.ts
│       ├── get-work-item-by-id.service.ts
│       └── get-work-item-by-id.init.ts
│
├── database/                  # Repository ports and SQL implementations
│   ├── work-item.repository.port.ts    # Repository interface
│   ├── folder.repository.port.ts
│   └── sql/
│       ├── entities/          # SQL schema definitions
│       │   └── work-item.sql-entity.ts
│       ├── mappers/           # Domain <-> persistence mappers
│       └── repositories/      # Repository implementations
│           └── work-item.sql.repository.ts
│
├── dtos/                      # Data transfer objects (top-level)
│   ├── work-item.dto.ts
│   ├── requests/
│   └── responses/
│
├── application/               # Event handler registrations
│   ├── domain-events.init.ts
│   ├── integration-events.init.ts
│   └── fifo-integration-events.init.ts
│
├── integration-events/        # Integration event definitions
│   └── work-item-created.integration-event.ts
│
└── interface-adapters/
    ├── hono/                  # HTTP route definitions
    │   └── routes.ts
    └── lambda/                # Lambda handlers (SQS, cron, Step Function)
```

## Core Patterns

### Domain-Driven Design

#### Entities

Objects with identity that persist over time:

```typescript
export class WorkItem extends Entity<WorkItemProps> {
  get number(): ItemNumber {
    return this.props.number;
  }

  get title(): string {
    return this.props.title;
  }

  updateTitle(title: string): void {
    this.props.title = title;
    this.addDomainEvent(new WorkItemTitleUpdatedEvent(this));
  }
}
```

#### Value Objects

Immutable objects defined by their attributes:

```typescript
export class ItemNumber extends ValueObject<{ value: string }> {
  static create(value: string): Result<ItemNumber, ValidationError> {
    if (!value || value.length === 0) {
      return Result.err(new ValidationError('Item number required'));
    }
    return Result.ok(new ItemNumber({ value }));
  }

  get value(): string {
    return this.props.value;
  }
}
```

#### Aggregate Roots

Entities that control access to a cluster of objects:

```typescript
export class Board extends AggregateRoot<BoardProps> {
  addItem(item: WorkItem): Result<void, DomainError> {
    // Business logic and invariant enforcement
    this.props.items.push(item);
    this.addDomainEvent(new ItemAddedToBoardEvent(this, item));
    return Result.ok(undefined);
  }
}
```

### CQRS Pattern

#### Commands

Commands represent intent to change state:

```typescript
// create-work-item.command.ts
export class CreateWorkItemCommand {
  constructor(
    public readonly organizationId: string,
    public readonly title: string,
    public readonly workTypeId: string,
    public readonly createdBy: string,
  ) {}
}
```

#### Command Handlers (Services)

Services execute commands and return results:

```typescript
// create-work-item.service.ts
export class CreateWorkItemService extends CommandHandlerBase<CreateWorkItemCommand> {
  constructor(
    private workItemRepository: WorkItemRepositoryPort,
    private itemCounterRepository: ItemCounterRepositoryPort,
    logger: Logger,
  ) {
    super(CreateWorkItemCommand, logger);
  }

  async handle(command: CreateWorkItemCommand): Promise<Result<WorkItemEntity, Error>> {
    // Business logic, validation, entity creation
    const workItemEntity = WorkItemEntity.create({
      title: command.title,
      // ...
    });

    // Persist
    await this.workItemRepository.save(workItemEntity);

    return Result.ok(workItemEntity);
  }
}

// Register with the DI container (at bottom of service file)
Injector.register(CreateWorkItemService, [
  WorkItemSqlRepository,
  ItemCounterSqlRepository,
  ItemLogger,
]);
```

#### Init Files

Register command handlers with the command bus. Init files also initialize any dependencies (other commands, queries, or event handlers) that the service needs:

```typescript
// create-work-item.init.ts
import { registerCommandHandler } from '@/libs/domain/commands/command-bus';
import { CreateWorkItemService } from './create-work-item.service';
import { initGetOrganizationByIdQuery } from '@/modules/organization/queries/get-organization-by-id/get-organization-by-id.init';

// Initialize dependencies
initGetOrganizationByIdQuery();

export function initCreateWorkItemCommand() {
  registerCommandHandler(CreateWorkItemService);
}
```

#### Queries

Queries retrieve data without side effects:

```typescript
// get-work-item.query.ts
export class GetWorkItemQuery {
  constructor(
    public readonly organizationId: string,
    public readonly itemNumber: string,
  ) {}
}
```

### Result Pattern

All operations return `Result<T, E>` instead of throwing:

```typescript
import { Result } from '@badrap/result';

async function updateItem(id: string, title: string): Promise<Result<WorkItem, DomainError>> {
  const item = await this.repository.findById(id);

  if (!item) {
    return Result.err(new NotFoundError('Item not found'));
  }

  const updateResult = item.updateTitle(title);
  if (updateResult.isErr) {
    return updateResult;
  }

  await this.repository.save(item);
  return Result.ok(item);
}

// Usage
const result = await updateItem('123', 'New Title');

if (result.isErr) {
  // Handle error
  return response.status(400).json({ error: result.error.message });
}

// Use result.value
return response.json(result.value);
```

### Event-Driven Architecture

#### Domain Events

Events emitted when state changes:

```typescript
export class WorkItemCreatedEvent extends DomainEvent {
  constructor(
    public readonly workItem: WorkItem,
  ) {
    super();
  }
}
```

#### Integration Events

Events for cross-service communication:

```typescript
export class WorkItemCreatedIntegrationEvent extends IntegrationEvent {
  constructor(
    public readonly organizationId: string,
    public readonly itemNumber: string,
  ) {
    super();
  }
}
```

#### Event Handlers

React to events. Handlers are registered in the `application/` directory's init files:

```typescript
export class SendNotificationOnItemCreated implements IEventHandler<WorkItemCreatedEvent> {
  async handle(event: WorkItemCreatedEvent): Promise<void> {
    // Send notification
  }
}
```

## HTTP Layer (Hono)

### Route Definition

```typescript
// routes.ts
export const itemRoutes = new Hono()
  .post('/items', createWorkItemHandler)
  .get('/items/:itemNumber', getWorkItemHandler)
  .patch('/items/:itemNumber', updateWorkItemHandler);
```

### Handler Pattern

```typescript
// create-work-item.handler.ts
export const createWorkItemHandler = async (c: Context) => {
  // 1. Parse and validate input
  const body = await c.req.json();
  const validated = CreateWorkItemRequestSchema.parse(body);

  // 2. Create command
  const command = new CreateWorkItemCommand(
    c.get('organizationId'),
    validated.title,
    validated.workTypeId,
    c.get('userId'),
  );

  // 3. Execute via command bus
  const result = await c.get('commandBus').execute(command);

  // 4. Handle result
  if (result.isErr) {
    return c.json({ error: result.error.message }, 400);
  }

  // 5. Return response
  return c.json(WorkItemResponseDto.fromEntity(result.value), 201);
};
```

## Repository Pattern

### Port (Interface)

Repository ports live directly under `database/` at the module level:

```typescript
// database/work-item.repository.port.ts
export interface WorkItemRepositoryPort {
  findByNumber(orgId: string, number: string): Promise<WorkItemEntity | null>;
  findById(id: string): Promise<WorkItemEntity | null>;
  save(item: WorkItemEntity): Promise<void>;
  delete(item: WorkItemEntity): Promise<void>;
}
```

### Implementation

Repository implementations live under `database/sql/repositories/`:

```typescript
// database/sql/repositories/work-item.sql.repository.ts
export class WorkItemSqlRepository implements WorkItemRepositoryPort {
  constructor(private readonly db: Database) {}

  async findByNumber(orgId: string, number: string): Promise<WorkItemEntity | null> {
    const row = await this.db.query.workItems.findFirst({
      where: and(
        eq(workItems.organizationId, orgId),
        eq(workItems.number, number),
      ),
    });

    return row ? WorkItemMapper.toDomain(row) : null;
  }

  async save(item: WorkItemEntity): Promise<void> {
    const data = WorkItemMapper.toPersistence(item);
    await this.db.insert(workItems).values(data).onConflictDoUpdate({
      target: workItems.id,
      set: data,
    });
  }
}
```

## Dependency Injection

DI is managed through the `Injector` singleton (which wraps BottleJS internally). Registration happens at the bottom of each service file, and resolution is handled automatically when init files call `registerCommandHandler()`:

```typescript
// Registration at the bottom of a service file
import { Injector } from '@/libs/domain/utils/di';

Injector.register(CreateWorkItemService, [
  SqlTransactionProvider,       // Dependencies resolved by class reference
  WorkItemSqlRepository,
  ItemCounterSqlRepository,
  ItemLogger,
]);

// Manual resolution (rarely needed)
const service = Injector.get(CreateWorkItemService);
```

## Database

### PostgreSQL with Drizzle ORM

Schema definition:

```typescript
// work-item.sql-entity.ts
export const workItems = pgTable('work_items', {
  id: uuid('id').primaryKey(),
  organizationId: uuid('organization_id').notNull(),
  number: varchar('number', { length: 50 }).notNull(),
  title: varchar('title', { length: 500 }).notNull(),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});
```

### Migrations

```bash
# Generate migration
cd backend && pnpm generate-sql

# Run migrations
./ds migrations run
```

## Testing

### Test Structure

```
backend/tests/
├── suits/              # Test suites by module
│   ├── item/
│   │   └── create-item.spec.ts
│   └── board/
├── utils/
│   ├── test-context.ts           # Test context and utilities
│   ├── test-context-registry.ts  # Test context registry
│   ├── mocks.ts                  # Shared mocks
│   ├── http.ts                   # HTTP test helpers
│   ├── sql.ts                    # SQL test helpers
│   └── user.ts                   # User test helpers
└── db/                 # Database test data and schemas
```

### Writing Tests

```typescript
describe('CreateWorkItem', () => {
  let ctx: TestContext;

  beforeEach(async () => {
    ctx = await TestContext.create();
  });

  afterEach(async () => {
    await ctx.cleanup();
  });

  it('should create a work item', async () => {
    const result = await ctx.commandBus.execute(
      new CreateWorkItemCommand(
        ctx.organization.id,
        'Test Item',
        ctx.workType.id,
        ctx.user.id,
      ),
    );

    expect(result.isOk).toBe(true);
    expect(result.value.title).toBe('Test Item');
  });
});
```

### Running Tests

```bash
cd backend

# Run all tests
pnpm test

# Run specific test file
pnpm test -- tests/suits/item/create-item.spec.ts

# Run with pattern
pnpm test -- -t "should create"

# Run with coverage
pnpm coverage
```

## Code Style

- **Never use `any` type** - Use proper types or `unknown`
- **Prefix interfaces with `I`** - e.g., `IWorkItemRepository`
- **Use async/await** - Not raw Promises
- **Use Result pattern** - Don't throw for expected errors
- **Single quotes, semicolons required**
- **Follow DDD naming conventions**
