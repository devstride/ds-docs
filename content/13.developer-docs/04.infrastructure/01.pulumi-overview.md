---
title: "Pulumi Basics"
description: "Understanding Pulumi in the DevStride context."
---

# Pulumi Basics

## What is Pulumi?

Pulumi is an infrastructure-as-code tool that lets you define cloud resources using familiar programming languages. DevStride uses Pulumi with TypeScript, which means the same language used for the backend and frontend also defines the infrastructure. Resources are declared in code, and Pulumi figures out what needs to be created, updated, or deleted to match.

Key concepts:

- **Stack** -- An isolated instance of your infrastructure. Each developer has their own stack (stage).
- **Resources** -- Cloud objects (Lambda functions, S3 buckets, DynamoDB tables, etc.) managed by Pulumi.
- **Outputs** -- Values exported from a stack (API URL, Cognito pool ID, bucket names) that other tools consume.
- **State** -- Pulumi tracks the current state of all resources in a backend (Pulumi Cloud by default). This is how it knows what to create, update, or delete.
- **Config** -- Per-stack configuration values stored in `Pulumi.{stage}.yaml` files.

## Pulumi Config

Each stage has a config file at `infra/Pulumi.{stage}.yaml`. This file contains the stage-specific values that control how infrastructure is deployed.

```yaml
config:
  devstride:stage: phil
  devstride:region: us-east-1
  devstride:domain: devstride.dev
  devstride:tier: personal
```

### Config Values

| Key | Required | Description |
|-----|----------|-------------|
| `devstride:stage` | Yes | Stage name (your first name for personal stages) |
| `devstride:region` | Yes | AWS region (`us-east-1`) |
| `devstride:domain` | Yes | Base domain (`devstride.dev`) |
| `devstride:tier` | No | Environment tier (auto-derived from stage name if omitted) |
| `devstride:sharedStackRef` | No | Reference to shared infrastructure stack (wildcard cert, hosted zone) |
| `devstride:cognitoUserPoolId` | Prod only | Existing Cognito user pool ID to import (production uses a pre-existing pool instead of creating one) |
| `devstride:useLumigo` | No | Enable Lumigo instrumentation (`true`/`false`, default `false`). Reserved for future use. |
| `devstride:lumigoToken` | No | Lumigo API token (secret). Only read when `useLumigo` is `true`. Reserved for future use. |

### Environment Tiers

The tier determines resource protection levels, log retention, and other environment-specific behavior:

| Tier | Stage Names | Description |
|------|-------------|-------------|
| **prod** | `prod`, `production` | Production environment. Maximum resource protection, 90-day log retention, 30-day Secrets Manager recovery. |
| **dev** | `dev` | Shared development environment. Same protections as prod. |
| **staging** | `staging` | Pre-production testing. Same protections as prod. |
| **personal** | Everything else (`phil`, `alex`, etc.) | Individual developer stages. No resource protection, 7-day log retention, immediate secret deletion. |

If `devstride:tier` is not set in the config, it is automatically derived from the stage name. For example, stage `phil` becomes tier `personal`, and stage `prod` becomes tier `prod`.

## Resource Naming

All AWS resources follow a consistent naming convention defined in `infra/helpers/naming.ts`:

```
{stage}-devstride-{resource}
```

**Examples:**

| Stage | Resource | Full Name |
|-------|----------|-----------|
| `phil` | state table | `phil-devstride-state-table` |
| `phil` | events bus | `phil-devstride` |
| `phil` | media bucket | `phil-devstride-media-bucket` |
| `dev` | state table | `dev-devstride-state-table` |
| `prod` | config secret | `prod-devstride-config-secret` |

This naming convention is also used to scope IAM policies. Lambda functions receive permissions only for resources matching `{stage}-devstride-*`, preventing cross-stage access.

## Domain Names

Domain names are resolved by `infra/helpers/domains.ts`. The `prod` and `dev` stages get clean subdomains; all other stages get a stage-prefixed subdomain.

| Stage | API | UI | Media | Importer |
|-------|-----|----|-------|----------|
| **prod** | `api.devstride.dev` | `app.devstride.dev` | `media.devstride.dev` | `importer.devstride.dev` |
| **dev** | `api.devstride.dev` | `app.devstride.dev` | `media.devstride.dev` | `importer.devstride.dev` |
| **phil** | `api-phil.devstride.dev` | `app-phil.devstride.dev` | `media-phil.devstride.dev` | `importer-phil.devstride.dev` |
| **staging** | `api-staging.devstride.dev` | `app-staging.devstride.dev` | `media-staging.devstride.dev` | `importer-staging.devstride.dev` |

::callout{type="info"}
Custom domains require a shared infrastructure stack with a wildcard SSL certificate and Route 53 hosted zone. Without it, CloudFront distributions use the default `*.cloudfront.net` domain. Set `devstride:sharedStackRef` in your Pulumi config to enable custom domains.
::

## Lambda Bundling

DevStride Lambda functions are written in TypeScript and bundled with esbuild during `pulumi up`. The bundling system is defined in `infra/helpers/bundler.ts`.

### How It Works

1. **Entry point resolution** -- Handler paths use SST-style notation (`backend/src/modules/.../api.handler`), which is split into a file path and export name.
2. **esbuild** -- `esbuild.buildSync()` runs synchronously, producing a minified ESM bundle targeting Node.js 22. AWS SDK packages are marked as external (provided by the Lambda runtime).
3. **Content-hash caching** -- After the first build, esbuild writes a metafile listing every input file. On subsequent runs, a SHA-256 hash of all inputs plus the `pnpm-lock.yaml` lockfile is compared against the stored hash. If nothing changed, the build is skipped entirely.
4. **Output** -- The bundle (`.mjs` + source map) is packaged into a Pulumi `AssetArchive` and uploaded to Lambda.

### Configuration

| Setting | Value |
|---------|-------|
| Target | `node22` (ESM format) |
| Architecture | `arm64` (Graviton2) |
| Memory | 1024 MB (default) |
| Timeout | 60 seconds (default) |
| Minification | Enabled |
| Tree-shaking | Enabled |
| Source maps | Enabled |
| External packages | `@aws-sdk/*`, `pg-native` |

### Static Files

Some Lambda functions need non-JavaScript files (JSON schemas, XLSX templates). These are declared as `staticFiles` in the Lambda definition and included in the archive alongside the bundle.

### Force Rebuild

To bypass the bundle cache and force a full rebuild:

```bash
PULUMI_FORCE_BUNDLE=true pulumi up -s yourname -C infra
```

## Step Functions (CDK Integration)

Complex multi-step workflows use AWS Step Functions. Because Pulumi does not have a native Step Functions state machine builder with the expressiveness of CDK's `sfn.Chain` DSL, DevStride uses `@pulumi/cdk` to bridge the two systems.

### How It Works

1. Step Function definitions use CDK constructs (`sfn.StateMachine`, `sfn.Chain`, `tasks.LambdaInvoke`, etc.) inside a `pulumicdk.Stack`.
2. Pulumi resolves all `Output<string>` values (bucket names, table names, etc.) to plain strings before CDK synthesis occurs. This bridging is handled automatically by `@pulumi/cdk`.
3. The synthesized CloudFormation template is deployed by Pulumi alongside all other resources.
4. State machine ARNs are exported back as Pulumi outputs, available for use by other modules (e.g., the Jobs service that triggers Step Function executions).

### Defined Workflows

| State Machine | Purpose |
|---------------|---------|
| ADO Import | Orchestrates Azure DevOps data migration |
| Jira Import | Orchestrates Jira data migration |
| Disable Project | Multi-step project deactivation |
| Disable Installation | Tears down an installation (iterates over projects) |
| Disable Credential | Revokes a credential (iterates over installations) |

## Stack Outputs

After deployment, Pulumi exports key infrastructure values as stack outputs. These are consumed by:

- The `ds` CLI (cached in `.ds/bind/` for fast local startup)
- The CI/CD pipeline (to configure frontend builds and deploy to S3)
- Other developers debugging or inspecting a stage

### Exported Outputs

| Output | Description |
|--------|-------------|
| `stage` | Stage name |
| `region` | AWS region |
| `apiUrl` | API Gateway endpoint URL |
| `cognitoUserPoolId` | Cognito user pool ID |
| `cognitoUserPoolClientId` | Cognito app client ID |
| `cognitoDomain` | Cognito hosted UI domain prefix |
| `uiUrl` | Frontend URL |
| `uiBucketName` | S3 bucket for frontend assets |
| `uiDistributionId` | CloudFront distribution ID for frontend |
| `mediaUrl` | Media CDN URL |
| `importerUrl` | Importer CDN URL |
| `stateTableName` | DynamoDB state table name |
| `eventBusName` | EventBridge bus name |
| `*StateMachineArn` | Step Function ARNs (5 total) |

### Refreshing Outputs Locally

After deploying, refresh your local environment with the latest outputs:

```bash
./ds outputs
```

This fetches all stack outputs and writes them to `.ds/bind/` where the backend reads them at startup.
